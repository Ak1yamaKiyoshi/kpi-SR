# Лабораторна робота: Зведення матриці до нормальної форми Фробеніуса та знаходження власних чисел

Задача лабораторної роботи полягала у тому, щоб звести матрицю до нормальної форми Фробеніуса, а потім знайти власні числа матриці А, тобто корені характеристичного рівняння.

## Функція для зведення матриці до нормальної форми Фробеніуса

```python
def matrixA_to_normal_frobenius_form(matrixA:np.ndarray):
    # Створюємо копію вхідної матриці для роботи
    P = matrixA.copy()
    # Визначаємо розмірність матриці
    n = len(matrixA)

    # Ініціалізуємо матриці перетворення M та її обернену M^(-1)
    # Ці матриці будуть використовуватися для перетворення P до форми Фробеніуса
    matrixM = [[0] * n for _ in range(n)]
    matrixMInverse = [[0] * n for _ in range(n)]
    
    # Ініціалізуємо M та M^(-1) як одиничні матриці
    # Це початковий стан перед перетвореннями
    for i in range(n):
        matrixM[i][i] = 1
        matrixMInverse[i][i] = 1
    
    # m = n-1 використовується для індексації останнього рядка/стовпця
    m = n - 1
    
    # Головний цикл перетворення
    # k визначає, який стовпець ми обробляємо на даній ітерації
    for k in range(m):
        # Цикл по рядках матриці
        # i йде від 1 до m, що відповідає обробці елементів під діагоналлю
        for i in range(1, m + 1):
            # Цикл по елементах рядка
            for j in range(m + 1):
                # Ця умова визначає, які елементи потрібно змінювати на поточній ітерації
                # Вона забезпечує обробку елементів під головною діагоналлю в потрібному порядку
                if m - k == m - i + 1:
                    if j != m - i:
                        # Обчислення недіагональних елементів M
                        # Ця формула забезпечує занулення відповідних елементів у P
                        matrixM[m - i][j] = -1 * P[m - i + 1][j] / P[m - i + 1][m - k - 1]
                    else:
                        # Обчислення діагональних елементів M
                        # Забезпечує правильне масштабування рядків
                        matrixM[m - i][j] = 1 / P[m - i + 1][m - k - 1]
                    # Заповнення M^(-1) - зберігає інформацію про перетворення
                    matrixMInverse[m - i][j] = P[m - i + 1][j]
        
        # Оновлення діагональних елементів M та M^(-1)
        # Це забезпечує невиродженість матриць перетворення
        for i in range(n):
            for j in range(n):
                if i == m - k:
                    if i == j:
                        matrixM[i][j] = 1
                        matrixMInverse[i][j] = 1
                    else:
                        matrixM[i][j] = 0
                        matrixMInverse[i][j] = 0
        
        # Створення копій для безпечного множення
        tempArray1 = matrixM.copy()
        tempArray2 = matrixMInverse.copy()
        
        # Виведення проміжних результатів для відстеження процесу
        print()
        print(f"MatrixM{m-k}inverse")
        print(np.array(matrixMInverse))
        print(f"MatrixA{k+1}")
        print(np.array(P))
        print(f"MatrixM{m-k}")
        print(np.array(matrixM))
        
        # Ключовий крок: P = M^(-1) * P * M
        # Це перетворення наближає P до форми Фробеніуса
        P = multiply3Arrays(tempArray2, P, tempArray1)

    # Повертаємо матрицю у формі Фробеніуса
    return P
```

## Важливе визначення

Матриця називається невиродженою (або оборотною), якщо її визначник не дорівнює нулю.
