

Задача цієї лабораторної роботи полягала в тому, щоб знайти корені рівняння трьома методами: хорд, Ньютона та бісекції.
Попередньо, у допрограмовому етапі потрібно відокремити корені рівняння двома методами: Гюа та Штурма. Проміжки, яким належать корені, показані на картинці.

### Метод Гюа

Ідея методу Гюа полягає в тому, щоб квадрат кожного з сусідніх коефіцієнтів був більшим за добуток його сусідніх коефіцієнтів. У випадку, якщо ця умова порушується, рівняння має принаймні одну пару комплексних коренів.

### Метод Штурма

У методі Штурма кожна зміна знаку значить проходження через корінь. Тобто кожен наступний многочлен є залишком від ділення двох попередніх, взятим з протилежним знаком.

## Програмна реалізація методів

### Метод бісекції
> Основна ідея методу бісекції полягає в послідовному звуженні інтервалу, який містить корінь рівняння, шляхом його поділу навпіл. Метод базується на теоремі про проміжне значення, яка стверджує, що якщо неперервна функція приймає значення різних знаків на кінцях відрізка, то всередині цього відрізка існує принаймні один корінь. Процес починається з вибору початкового інтервалу, на кінцях якого функція має різні знаки. На кожній ітерації інтервал ділиться навпіл, і визначається, в якій половині знаходиться корінь, шляхом перевірки знаку функції в середній точці. Половина інтервалу, де функція змінює знак, вибирається для наступної ітерації. Цей процес повторюється, послідовно звужуючи інтервал, доки його ширина не стане меншою за задану точність. Метод гарантовано збігається, але може бути повільним для функцій з повільною зміною знаку поблизу кореня. Перевагами методу є його простота, надійність та гарантована збіжність для неперервних функцій, що робить його корисним для знаходження коренів рівнянь, особливо коли інші методи можуть бути нестабільними.

```python
def method_bisection(kof, a, b):
    # Задання точності
    e = 0.000001
    x = 0
    n = 0
    
    # Шукаємо 
    while abs(b - a) > e:
        n += 1
        # Обчислення середньої точки, тобто половину інтервалу
        x = (a + b) / 2 # у межах заданого інтервалу 
        
        # Перевірка знаку функції на кінцях відрізка
        # Перевіряємо, чи міняє функція свій знак в інтервалі a x 
        # Тобто рахуємо початок інтервалу та середину інтервалу.
        # Якщо їх добуток від'ємний, значить якесь із значень 0
        # тобто значення змінилось 
        if result_function(a, kof) * result_function(x, kof) < 0:
            # І якщо значення змінюється, значить корінь лежить у лівій половині
            b = x
        else:
            # Інакше Корінь знаходиться в правій половині
            a = x
    
    print("Number of iteration:", n)
    return x
```

### Метод хорд
> Основна ідея методу хорд полягає в послідовному наближенні до кореня рівняння шляхом апроксимації функції хордами. Метод починається з вибору двох початкових точок, де функція має різні знаки. На кожній ітерації проводиться хорда між цими двома точками, і точка перетину хорди з віссю абсцис приймається як нове наближення до кореня. Ця нова точка замінює одну з початкових точок таким чином, щоб функція на нових кінцях відрізка зберігала різні знаки. Процес повторюється, поступово наближаючись до справжнього кореня. Вибір початкової точки базується на аналізі знаків функції та її другої похідної для забезпечення збіжності. Метод хорд зазвичай збігається швидше, ніж метод бісекції, особливо коли функція близька до лінійної в околі кореня. Однак, на відміну від методу бісекції, метод хорд не гарантує знаходження кореня в заданому інтервалі, але за певних умов може забезпечити швидшу збіжність. Метод особливо ефективний для функцій, які мають майже лінійну поведінку поблизу кореня, і часто використовується в комбінації з іншими методами для підвищення ефективності пошуку коренів рівнянь.

```python
def method_chord(kof, a, b):
    e = 0.000001
    
    # Обчислюємо першу та другу похідні.
    # Це потрібно для вибору початкової точки та оцінки збіжності.
    fkof = derivative(kof)
    skof = derivative(fkof)
    
    # Вибір початкової точки базується на теоремі про збіжність методу хорд.
    # Ми вибираємо точку, де функція та її друга похідна мають однаковий знак.
    if result_function((a + b) / 2, fkof) * result_function((a + b) / 2, skof) > 0:
        x0 = b
        x1 = a
    else:
        x0 = a
        x1 = b
    
    current_x = 0
    prev_x = x1
    n = 0
    
    while True:
        n += 1
        # Формула методу хорд. Геометрично, це знаходження точки перетину
        # хорди, що з'єднує точки (x0, f(x0)) та (prev_x, f(prev_x)), з віссю x.
        current_x = prev_x - result_function(prev_x, kof) / (result_function(prev_x, kof) - result_function(x0, kof)) * (prev_x - x0)
        
        # Перевіряємо, чи досягнуто заданої точності.
        # Це оцінка того, наскільки близько ми до справжнього кореня.
        if abs(current_x - prev_x) < e:
            break
        
        prev_x = current_x
    
    print("Number of iteration:", n)
    return current_x
```

### Метод Ньютона
> Основна ідея методу Ньютона, також відомого як метод дотичних, полягає в послідовному наближенні до кореня рівняння шляхом лінеаризації функції в околі поточного наближення. Метод починається з вибору початкової точки, яка обирається на основі аналізу знаків функції та її другої похідної для забезпечення збіжності. На кожній ітерації метод обчислює дотичну до графіка функції в поточній точці і знаходить точку перетину цієї дотичної з віссю абсцис. Ця точка перетину приймається як нове наближення до кореня. Процес повторюється, використовуючи формулу Ньютона, яка враховує значення функції та її першої похідної в поточній точці. Метод Ньютона відомий своєю швидкою збіжністю, особливо коли початкове наближення достатньо близьке до справжнього кореня. Він має квадратичну швидкість збіжності, що робить його одним з найефективніших методів пошуку коренів для гладких функцій. Однак метод чутливий до вибору початкової точки і може розбігатися або збігатися до іншого кореня, якщо початкове наближення вибрано невдало. Метод Ньютона широко застосовується в чисельному аналізі, оптимізації та інших областях, де потрібно знаходити корені рівнянь або екстремуми функцій.

```python
def method_newton(kof, a, b):
    e = 0.000001
    
    # Обчислюємо першу та другу похідні.
    # Перша похідна використовується у формулі Ньютона,
    # друга - для вибору початкової точки.
    fkof = derivative(kof)
    skof = derivative(fkof)
    
    # Вибір початкової точки базується на теоремі про збіжність методу Ньютона.
    # Ми вибираємо точку, де функція та її друга похідна мають однаковий знак.
    if result_function((a + b) / 2, fkof) * result_function((a + b) / 2, skof) > 0:
        prev_x = b
    else:
        prev_x = a
    
    current_x = 0
    n = 0
    
    while True:
        n += 1
        # Формула методу Ньютона. Геометрично, це знаходження точки перетину
        # дотичної до графіка функції в точці prev_x з віссю x.
        current_x = prev_x - result_function(prev_x, kof) / result_function(prev_x, fkof)

        # Перевіряємо, чи досягнуто заданої точності.
        if abs(current_x - prev_x) < e:
            break
        
        prev_x = current_x
    
    print("Number of iteration:", n)
    return current_x
```