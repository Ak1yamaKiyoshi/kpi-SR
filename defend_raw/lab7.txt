


Трапезоїдний метод 
# Обчислення інтегралу за формулою трапецій
# Інтеграл рахується сумі усіх трапецій, де формула площі трапеції 
# S_i = h * (f(x_i) + f(x_(i+1))) / 2
# np.sum(y[1:-1]) - сума усіх проміжних трапецій, 
# y[0] y[-1] - перша та остання точка  
# (b - a) еквівалентно h у формулі суми трапеції, 

# S ≈ h/2 * [f(x_0) + 2f(x_1) + 2f(x_2) + ... + 2f(x_(n-1)) + f(x_n)]

- - - 

error = ((b - a) ** 3 / (12 * n ** 2)) * maximum
# Похибка методу трапеції пов'язана з кривизною функції, за що і відповідає друга похідна
""" 
n^2 або квадратична зміна похибки:
    Коли ми збільшуємо n вдвічі, ми зменшуємо ширину кожного підінтервалу вдвічі.
    Це призводить до того, що площа кожної окремої трапеції стає в 4 рази точнішою (2² = 4).
    Тому загальна похибка зменшується пропорційно n².
(b - a)^3 з'являється через те, що коли ми інтегруємо, з'являється третій множник, тобто сам інтервал. 
А maximum, тобто максимальна абсолютна кривизна функції у заданому інтервалі
враховує найгірший варіант похибки
"""

- - -

Поліном лежандра 

def leggauss(deg):
    if not isinstance(deg, int) or deg <= 0:
        raise ValueError("deg must be a positive integer")
    # Перше наближення коренів
    c = np.zeros(deg + 1)
    c[-1] = 1
    m = leg.legcompanion(c)
    """ 
        Ми створюємо матрицю супутник щоб перевести задачу 
        знаходження коренів рівняння у задачу знаходження власних значень матриці. 
            [0  0  0  ... 0  -a₀]
            [1  0  0  ... 0  -a₁]
            [0  1  0  ... 0  -a₂]
            [.  .  .  ... .   . ]
            [0  0  0  ... 1  -aₙ₋₁]
        Це робиться через те, що для цього є ефективн алгоритми. 
    """

    x = linalg.eigvalsh(m)
    """
    Пошук власних значень 
    """

    # Значення полінома у знайдених коренях (власних значеннях матриці) 
    fm = leg.legval(x, c[1:])
    # Нормалізація значення полінома 
    fm /= np.abs(fm).max()
    # І так само нормалізуємо похідну 
    df /= np.abs(df).max()
    # Саме обчислення ваг, 
    # Тобто ваги це обернуті нормалізоване максимальне значення полінома помножене на нахил
    w = 1/(fm * df)
    
    # Робимо ваги симетричними. Ваги розумірністю W_n, де n це кількість точок інтегрування
    w = (w + w[::-1])/2
    x = (x - x[::-1])/2

    # Масштабуємо ваги 
    w *= 2. / w.sum()

    # Ваги у цьому випадку, це коофіцієнти які визначають важливість кожної точки інтегрування
    # Чим більша похідна, тобто швидкість зміни функції, тим важливіша точка 
    # А також чим далі точки одне від одної тим важливіша кожна.
    return x, w


- - - 


Квадратичний метод гауса 



def gauss_quadrature(f, a, b, eps):
    """
    Метод Гауса для обчислення інтегралу.
    Параметри:
    - f: функція для інтегрування
    - a, b: межі інтегрування
    - eps: бажана точність
    Повертає:
    - значення інтегралу
    - оцінку похибки
    """
    n = 1
    prev_result = 0
    
    while True:
        # Отримуємо точки та їх вагу, 
        x, w = np.polynomial.legendre.leggauss(n)
        # Переводимо стандартний інтервал у заданий
        # -1 1 у a b  
        t = 0.5 * (b - a) * x + 0.5 * (b + a)
        # Поточне значення інтеграла це зважена сума значень функції.
        current_result = 0.5 * (b - a) * np.sum(w * f(t))
        
        # Похибка визначається різницею поточного від попереднього значення 
        error = abs(current_result - prev_result)

        # Перестаємо інтегрувати (зменшуючи крок) тоді, коли помилка стає 
        # меншою за задану точність, відповідно тоді, бажаної точності досягнено.
        if error < eps and n > 1:
            return current_result, error
        
        """ 
        У методах чисельного інтгрування результат поступово наближується до значення інтеграла
        І відповідно, різниця між цими значеннями дає нам розуміння, яка точність у поточного наближення
        
        """
        prev_result = current_result
        n *= 2


--- 
Метод називєаться квадратурним
Поточний результат інтеграла і є квадратурою, тобто, площею або об'ємом