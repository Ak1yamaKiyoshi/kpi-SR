# Лабораторна робота: Методи чисельного інтегрування

Задача лабораторної роботи полягала у тому, щоб знайти інтеграл методом Гаусса для всіх варіантів та трапезоїдним методом за моїм варіантом.

## Трапезоїдний метод
> Основна ідея трапезоїдного методу полягає в апроксимації площі під кривою функції сумою площ трапецій. Метод розбиває інтервал інтегрування на певну кількість підінтервалів і замінює криву функції на кожному підінтервалі прямою лінією, утворюючи трапецію. Площа кожної трапеції обчислюється за формулою: половина суми значень функції на кінцях підінтервалу, помножена на ширину підінтервалу. Сума площ усіх трапецій дає наближене значення інтеграла. Метод реалізується ітеративно, починаючи з малої кількості підінтервалів і подвоюючи їх кількість на кожній ітерації, доки не буде досягнута задана точність. Точність оцінюється за допомогою верхньої межі похибки, яка залежить від другої похідної функції та кількості підінтервалів. Трапезоїдний метод є простим у реалізації та досить точним для гладких функцій. Він особливо ефективний, коли функція має невелику кривизну на інтервалі інтегрування. Метод забезпечує квадратичну збіжність, що означає, що похибка зменшується пропорційно квадрату кількості підінтервалів. Це робить його корисним інструментом для чисельного інтегрування в багатьох практичних застосуваннях.

```python
# Обчислення інтегралу за формулою трапецій
# Інтеграл рахується сумі усіх трапецій, де формула площі трапеції 
# S_i = h * (f(x_i) + f(x_(i+1))) / 2
# np.sum(y[1:-1]) - сума усіх проміжних трапецій, 
# y[0] y[-1] - перша та остання точка  
# (b - a) еквівалентно h у формулі суми трапеції, 

# S ≈ h/2 * [f(x_0) + 2f(x_1) + 2f(x_2) + ... + 2f(x_(n-1)) + f(x_n)]

def trapezoidal_integral(f, a, b, eps):
    n = 2  
    while True:
        x = np.linspace(a, b, n + 1)
        y = f(x)

        integral = (b - a) / (2 * n) * (y[0] + 2 * np.sum(y[1:-1]) + y[-1])
        
        h = (b - a) / n
        maximum = np.max(np.abs(f_prime2(np.linspace(a, b, 100))))
        error = ((b - a) ** 3 / (12 * n ** 2)) * maximum

        
        if error < eps:
            break
        n *= 2  
    return integral, error


error = ((b - a) ** 3 / (12 * n ** 2)) * maximum
# Похибка методу трапеції пов'язана з кривизною функції, за що і відповідає друга похідна
""" 
n^2 або квадратична зміна похибки:
    Коли ми збільшуємо n вдвічі, ми зменшуємо ширину кожного підінтервалу вдвічі.
    Це призводить до того, що площа кожної окремої трапеції стає в 4 рази точнішою (2² = 4).
    Тому загальна похибка зменшується пропорційно n².
(b - a)^3 з'являється через те, що коли ми інтегруємо, з'являється третій множник, тобто сам інтервал. 
А maximum, тобто максимальна абсолютна кривизна функції у заданому інтервалі
враховує найгірший варіант похибки
"""
```

## Поліном Лежандра
> Основна ідея поліномів Лежандра полягає у створенні системи ортогональних поліномів з унікальними властивостями, які роблять їх потужним інструментом у математиці та фізиці. Ці поліноми визначаються на інтервалі [-1, 1] і характеризуються ортогональністю, що означає, що інтеграл добутку двох різних поліномів Лежандра на цьому інтервалі дорівнює нулю. Вони мають рекурентні співвідношення, які дозволяють легко обчислювати кожен наступний поліном через попередні. Корені поліномів Лежандра симетрично розташовані на інтервалі [-1, 1] і використовуються як оптимальні точки для чисельного інтегрування.  ці поліноми використовуються для визначення оптимальних точок інтегрування та відповідних вагових коефіцієнтів. Процес включає знаходження коренів поліномів та обчислення вагових коефіцієнтів на основі значень поліномів та їх похідних у цих коренях. Цей підхід забезпечує високу точність інтегрування з використанням відносно невеликої кількості точок.

```python
def leggauss(deg):
    if not isinstance(deg, int) or deg <= 0:
        raise ValueError("deg must be a positive integer")
    # Перше наближення коренів
    c = np.zeros(deg + 1)
    c[-1] = 1
    m = leg.legcompanion(c)
    """ 
        Ми створюємо матрицю супутник щоб перевести задачу 
        знаходження коренів рівняння у задачу знаходження власних значень матриці. 
            [0  0  0  ... 0  -a₀]
            [1  0  0  ... 0  -a₁]
            [0  1  0  ... 0  -a₂]
            [.  .  .  ... .   . ]
            [0  0  0  ... 1  -aₙ₋₁]
        Це робиться через те, що для цього є ефективні алгоритми. 
    """

    x = linalg.eigvalsh(m)
    """
    Пошук власних значень 
    """

    # Значення полінома у знайдених коренях (власних значеннях матриці) 
    fm = leg.legval(x, c[1:])
    # Нормалізація значення полінома 
    fm /= np.abs(fm).max()
    # І так само нормалізуємо похідну 
    df /= np.abs(df).max()
    # Саме обчислення ваг, 
    # Тобто ваги це обернуті нормалізоване максимальне значення полінома помножене на нахил
    w = 1/(fm * df)
    
    # Робимо ваги симетричними. Ваги розмірністю W_n, де n це кількість точок інтегрування
    w = (w + w[::-1])/2
    x = (x - x[::-1])/2

    # Масштабуємо ваги 
    w *= 2. / w.sum()

    # Ваги у цьому випадку, це коефіцієнти які визначають важливість кожної точки інтегрування
    # Чим більша похідна, тобто швидкість зміни функції, тим важливіша точка 
    # А також чим далі точки одне від одного тим важливіша кожна.
    return x, w
```

## Квадратурний метод Гаусса
> Основна ідея квадратурного методу Гауса полягає в оптимальному виборі точок інтегрування та вагових коефіцієнтів для максимально точного обчислення інтегралу. Метод базується на апроксимації підінтегральної функції поліномом високого ступеня і використанні спеціально підібраних точок (коренів поліномів Лежандра) для обчислення інтегралу. Ключові аспекти методу включають: вибір оптимальних точок інтегрування, які є коренями поліномів Лежандра; використання відповідних вагових коефіцієнтів для кожної точки; перетворення стандартного інтервалу [-1, 1] до заданого інтервалу інтегрування [a, b]. Метод ітеративно збільшує кількість точок інтегрування, доки не буде досягнута задана точність. Оцінка похибки здійснюється шляхом порівняння послідовних наближень. Квадратурний метод Гауса відомий своєю високою точністю при відносно малій кількості точок інтегрування, особливо для гладких функцій. Він забезпечує точне обчислення інтегралів для поліномів до ступеня 2n-1, де n - кількість точок інтегрування. Метод ефективний для широкого класу функцій і часто використовується в чисельному аналізі, фізиці та інженерних розрахунках, де потрібна висока точність при обмежених обчислювальних ресурсах.

```python
def gauss_quadrature(f, a, b, eps):
    """
    Метод Гауса для обчислення інтегралу.
    Параметри:
    - f: функція для інтегрування
    - a, b: межі інтегрування
    - eps: бажана точність
    Повертає:
    - значення інтегралу
    - оцінку похибки
    """
    n = 1
    prev_result = 0
    
    while True:
        # Отримуємо точки та їх вагу, 
        x, w = np.polynomial.legendre.leggauss(n)
        # Переводимо стандартний інтервал у заданий
        # -1 1 у a b  
        t = 0.5 * (b - a) * x + 0.5 * (b + a)
        # Поточне значення інтеграла це зважена сума значень функції.
        current_result = 0.5 * (b - a) * np.sum(w * f(t))
        
        # Похибка визначається різницею поточного від попереднього значення 
        error = abs(current_result - prev_result)

        # Перестаємо інтегрувати (зменшуючи крок) тоді, коли помилка стає 
        # меншою за задану точність, відповідно тоді, бажаної точності досягнено.
        if error < eps and n > 1:
            return current_result, error
        
        """ 
        У методах чисельного інтегрування результат поступово наближується до значення інтеграла
        І відповідно, різниця між цими значеннями дає нам розуміння, яка точність у поточного наближення
        """
        prev_result = current_result
        n *= 2
```



Метод називається квадратурним. Поточний результат інтеграла і є квадратурою, тобто, площею або об'ємом.

## Обмеження 
- Квадратурний метод Гаусса обмежений у застосуванні до функцій, які можна добре апроксимувати поліномами. Його ефективність знижується для функцій з різкими змінами або сингулярностями. Метод також вимагає обчислення коренів поліномів Лежандра та відповідних вагових коефіцієнтів, що може бути складним для високих степенів.

- Поліноми Лежандра, хоча і є потужним інструментом для чисельного інтегрування, мають обмеження в застосуванні поза інтервалом [-1, 1]. Для інтегрування на інших інтервалах потрібно виконувати масштабування, що може впливати на точність. Крім того, для функцій, які погано апроксимуються поліномами, використання поліномів Лежандра може призвести до значних похибок.

- Трапезоїдний метод, хоча і простий у реалізації, має відносно низьку точність порівняно з більш складними методами. Він особливо неефективний для функцій з великою кривизною, оскільки апроксимує криву прямими лінями. Метод також може накопичувати значні похибки при інтегруванні на великих інтервалах або при використанні грубої сітки.