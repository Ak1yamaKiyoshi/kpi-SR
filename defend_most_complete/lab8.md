# Лабораторна робота: Розв'язання задачі Коші

Задача цієї лабораторної роботи полягала у тому, щоб вирішити задачу Коші методами Рунге-Кутта та Адамса.

## Метод Рунге-Кутта
> Основна ідея методу Рунге-Кутта четвертого порядку полягає у  Метод використовує чотири проміжні обчислення на кожному кроці інтегрування для досягнення високої точності. Процес починається з заданих початкових умов і послідовно обчислює наближені значення розв'язку в дискретних точках. На кожному кроці метод оцінює нахил функції в чотирьох точках: на початку інтервалу, двічі в середині і в кінці. Ці чотири оцінки потім комбінуються з різними ваговими коефіцієнтами для отримання кінцевого наближення на даному кроці. Таке зважене усереднення дозволяє досягти четвертого порядку точності, що означає, що локальна похибка на кожному кроці пропорційна п'ятому степеню розміру кроку. Метод не вимагає явного обчислення похідних вищих порядків, що робить його ефективним і широко застосовуваним. Хоча метод Рунге-Кутта четвертого порядку не передбачає адаптивної зміни кроку, він часто доповнюється механізмами контролю похибки, такими як обчислення контрольного параметра tau, для оцінки якості наближення. Цей метод забезпечує хороший баланс між точністю та обчислювальною ефективністю, що робить його популярним вибором для розв'язання широкого спектру задач у фізиці, інженерії та інших областях, де потрібно чисельно розв'язувати диференціальні рівняння.

Метод Рунге-Кутта рахує зважене середнє значення наближень похідної нахилів у інтервалі x+h для обрахунку наступного значення y.
- k1 - це нахил на початку інтервалу.
- k2 - це нахил у середині інтервалу, використовуючи k1 для оцінки y.
- k3 - це також нахил у середині інтервалу, але використовуючи k2.
- k4 - це нахил у кінці інтервалу, використовуючи k3.

```python
import numpy as np

def runge_kutta_4(f: callable, x0: float, y0: np.ndarray, xf: float, n: int) -> tuple[np.ndarray, np.ndarray]:
    """
    Метод Рунге-Кутта 4-го порядку для розв'язання систем ЗДР.
    
    Параметри:
    f -- функція, що визначає систему ЗДР dy/dx = f(x, y)
    x0 -- початкове значення x
    y0 -- початковий вектор y
    xf -- кінцеве значення x
    n -- кількість кроків інтегрування
    
    Повертає:
    x -- масив значень x
    y -- масив значень y
    """
    h = (xf - x0) / n  # крок інтегрування
    x = np.linspace(x0, xf, n + 1)  # масив значень x
    y = np.zeros((n + 1, len(y0)))  # масив для зберігання значень y
    y[0] = y0  # початкове значення y

    for i in range(n):
        k1 = h * f(x[i], y[i])
        k2 = h * f(x[i] + h/2, y[i] + k1/2)
        k3 = h * f(x[i] + h/2, y[i] + k2/2)
        k4 = h * f(x[i] + h, y[i] + k3)

        y[i+1] = y[i] + (k1 + 2*k2 + 2*k3 + k4) / 6

        # Обчислення контрольного параметра tau
        """
            k1-k2 нормалізують значення похибки k2-k3 (похибка між двома послідовними наближеннями)
        """
        tau = np.max(np.abs((k2 - k3) / (k1 - k2 + 1e-15)))  # додаємо малу величину для уникнення ділення на нуль
        if tau > 0.1: # Метод рунге кутта не передбачає адаптивної зміни кроку. 
            print(f"Увага: tau = {float(tau):.4f} > 0.1 при x = {float(x[i+1]):.4f}")
    return x, y

def runge_rule(runge_kutta_4, f, x0, y0, xf, n, m):
    """
    Реалізація правила Рунге для оцінки похибки.
    
    Параметри:
    runge_kutta_4 -- функція методу Рунге-Кутта 4-го порядку
    f -- функція, що визначає ЗДР dy/dx = f(x, y)
    x0, y0 -- початкові умови
    xf -- кінцеве значення x
    n -- кількість кроків інтегрування
    m -- порядок похибки методу
    
    Повертає:
    epsilon -- оцінка похибки
    """
    _, y_n = runge_kutta_4(f, x0, y0, xf, n)
    _, y_2n = runge_kutta_4(f, x0, y0, xf, 2*n)
    epsilon = np.max(np.abs(y_n[-1] - y_2n[-1])) / (2**m - 1)
    return epsilon
```

## Метод Адамса
> Основна ідея методу Адамса полягає у використанні інформації про попередні точки розв'язку для прогнозування та корекції наступного значення при розв'язанні звичайних диференціальних рівнянь. Метод Адамса є багатокроковим методом, який складається з двох основних етапів: предиктора (екстраполяції) та коректора (інтерполяції). Спочатку метод використовує інший однокроковий метод (зазвичай метод Рунге-Кутта) для обчислення перших кількох точок, необхідних для старту. Далі для кожного наступного кроку метод спочатку прогнозує (екстраполює) значення розв'язку, використовуючи інформацію про попередні точки та їх похідні. Потім це прогнозоване значення коригується (інтерполюється) з урахуванням обчисленої похідної в новій точці. Такий підхід дозволяє досягти високої точності при відносно низьких обчислювальних витратах, оскільки використовує інформацію, вже обчислену на попередніх кроках. Метод Адамса особливо ефективний для розв'язання задач, де потрібно обчислити розв'язок на довгому інтервалі з високою точністю. Він забезпечує хороший баланс між точністю та ефективністю, що робить його популярним у багатьох областях науки та інженерії, де необхідно чисельно розв'язувати диференціальні рівняння.


Метод Адамса дивиться на попередні значення y та їх похідні, щоб спрогнозувати наступне значення (предиктор), а потім уточнює його, використовуючи це прогнозоване значення разом з минулими значеннями та їх похідними (коректор). Цей двоетапний процес дозволяє методу адаптуватися до змін у поведінці функції, забезпечуючи більшу точність, ніж простіші методи.

```python
def adams_method(f, x0, y0, xf, n):
    """
    Метод Адамса для розв'язання звичайних диференціальних рівнянь.

    Параметри:
    f -- функція правої частини ДР: dy/dx = f(x, y)
    x0 -- початкове значення x
    y0 -- початкове значення y
    xf -- кінцеве значення x
    n -- кількість кроків

    Повертає:
    x -- масив значень x
    y -- масив значень y
    """
    h = (xf - x0) / n  # крок
    x = np.linspace(x0, xf, n + 1)
    y = np.zeros(n + 1)
    y[0] = y0

    # Використовуємо метод Рунге-Кутта 4-го порядку для перших 4 точок
    for i in range(3):
        k1 = h * f(x[i], y[i])
        k2 = h * f(x[i] + h/2, y[i] + k1/2)
        k3 = h * f(x[i] + h/2, y[i] + k2/2)
        k4 = h * f(x[i] + h, y[i] + k3)
        y[i+1] = y[i] + (k1 + 2*k2 + 2*k3 + k4) / 6

    # Метод Адамса
    for i in range(3, n):
        # Екстраполяційна формула (предиктор)
        y_pred = y[i] + h/24 * (55*f(x[i], y[i]) - 59*f(x[i-1], y[i-1]) + 
                                37*f(x[i-2], y[i-2]) - 9*f(x[i-3], y[i-3]))
        
        # Інтерполяційна формула (коректор)
        y[i+1] = y[i] + h/24 * (9*f(x[i+1], y_pred) + 19*f(x[i], y[i]) - 
                                5*f(x[i-1], y[i-1]) + f(x[i-2], y[i-2]))

    return x, y
```

## Фазовий портрет у задачі Коші
> Основна ідея фазового портрету в задачі Коші полягає в графічному відображенні поведінки динамічної системи в просторі її змінних стану. Цей метод візуалізує еволюцію системи в часі, показуючи траєкторії руху в просторі змінних, 

Фазовий портрет у задачі Коші - це графічне представлення розв'язків системи диференціальних рівнянь, яке дозволяє нам візуально осягнути поведінку системи за різних початкових умов. 

Ключові аспекти фазового портрету:
- Кожна точка відповідає можливому стану системи
- Криві показують еволюцію системи з часом (фазові траєкторії)
- Точки рівноваги - місця, де всі похідні дорівнюють нулю
- Сепаратриси - траєкторії, які розділяють різні типи поведінки системи

Переваги використання фазового портрету:
1. Дозволяє аналізувати стійкість системи
2. Визначає наявність періодичних розв'я    зків або хаотичної поведінки
3. Не вимагає точних аналітичних розв'язків
4. Дозволяє проводити біфуркаційний аналіз
5. Візуалізує вплив різних початкових умов на довгострокову поведінку системи

Фазовий портрет є потужним інструментом для якісного аналізу динамічних систем, який дозволяє глибоко зрозуміти поведінку системи без необхідності вирішувати складні рівняння аналітично.
