# Лабораторна робота: Зведення матриці до нормальної форми Фробеніуса та знаходження власних чисел

Задача лабораторної роботи полягала у тому, щоб звести матрицю до нормальної форми Фробеніуса, а потім знайти власні числа матриці А, тобто корені характеристичного рівняння.

## Функція для зведення матриці до нормальної форми Фробеніуса
> Основна ідея методу Фробеніуса полягає в перетворенні вихідної матриці до спеціальної канонічної форми через послідовність подібних перетворень. Процес відбувається ітеративно, обробляючи матрицю стовпець за стовпцем від останнього до першого. На кожній ітерації формується матриця перетворення та її обернена, які використовуються для занулення елементів під головною діагоналлю у відповідному стовпці. Ключовим кроком є множення поточної матриці зліва на обернену матрицю перетворення і справа на саму матрицю перетворення. Це наближення покращується з кожною ітерацією, оскільки кожне таке множення зануляє елементи в одному стовпці під головною діагоналлю, крім першого ненульового елемента, який стає одиницею. Таким чином, з кожним кроком матриця все більше наближається до форми Фробеніуса, де всі елементи під головною піддіагоналлю є одиницями, а решта елементів під головною діагоналлю - нулями. Цей процес зберігає характеристичний многочлен матриці, що робить отриману форму корисною для подальшого аналізу властивостей вихідної матриці, особливо для знаходження власних значень.


> Метод Данилевського - це алгоритм для знаходження власних значень та власних векторів квадратної матриці. Він працює шляхом послідовного перетворення вихідної матриці до спеціальної форми, відомої як нормальна форма Фробеніуса.
> Процес починається з вихідної матриці A. Метод послідовно застосовує подібні перетворення до матриці, використовуючи спеціально сконструйовані матриці перетворення. Ці перетворення змінюють структуру матриці, не змінюючи її власних значень.
> На кожному кроці створюється матриця перетворення, яка змінює один рядок матриці. Ці матриці перетворення конструюються так, щоб поступово приводити матрицю до бажаної форми. Процес починається з нижнього рядка і рухається вгору.
> Після застосування всіх перетворень отримується матриця P у нормальній формі Фробеніуса. Ця форма має особливу структуру: всі елементи під головною діагоналлю дорівнюють 1, а всі інші елементи, крім першого рядка, дорівнюють 0.
> Ключова особливість нормальної форми Фробеніуса полягає в тому, що її характеристичне рівняння має простий вигляд. Коефіцієнти характеристичного полінома безпосередньо відповідають елементам першого рядка матриці P. Це дозволяє легко записати характеристичне рівняння і знайти його корені, які є власними значеннями матриці.
> Після знаходження власних значень, метод Данилевського дозволяє просто обчислити відповідні власні вектори. Для матриці в нормальній формі Фробеніуса власні вектори мають вигляд [λ^(n-1), λ^(n-2), ..., λ, 1], де λ - власне значення, а n - розмірність матриці.
> Нарешті, власні вектори вихідної матриці A отримуються шляхом зворотного перетворення власних векторів матриці P, використовуючи добуток матриць перетворення.

import numpy as np
from scipy import linalg

# Вхідна матриця A розміру 4x4
A = np.array([
    [7.03, 1.14, 0.93, 1.135],
    [1.14, 3.39, 1.3, 0.16],
    [0.93, 1.3, 6.21, 2.1],
    [1.135, 0.16, 2.1, 5.33]
])
```python
# Метод Данилевського для приведення матриці до нормальної форми Фробеніуса
# Загальна формула подібного перетворення: A' = M^(-1) * A * M

# Перший етап
# Створюємо M3 - одиничну матрицю 4x4
M3 = np.eye(4)
# Змінюємо третій рядок M3 для перетворення останнього рядка A
M3[2, :] = [-A[3,0]/A[3,2], -A[3,1]/A[3,2], 1/A[3,2], -A[3,3]/A[3,2]]

# Застосовуємо подібне перетворення: A1 = M3^(-1) * A * M3
A1 = np.linalg.inv(M3) @ A @ M3

# Другий етап
# Створюємо M2 - одиничну матрицю 4x4
M2 = np.eye(4)
# Змінюємо другий рядок M2 для перетворення передостаннього рядка A1
M2[1, :] = [-A1[2,0]/A1[2,1], 1/A1[2,1], -A1[2,2]/A1[2,1], -A1[2,3]/A1[2,1]]

# Застосовуємо подібне перетворення: A2 = M2^(-1) * A1 * M2
A2 = np.linalg.inv(M2) @ A1 @ M2

# Третій етап
# Створюємо M1 - одиничну матрицю 4x4
M1 = np.eye(4)
# Змінюємо перший рядок M1 для перетворення другого рядка A2
M1[0, :] = [1/A2[1,0], -A2[1,1]/A2[1,0], -A2[1,2]/A2[1,0], -A2[1,3]/A2[1,0]]

# Застосовуємо подібне перетворення: P = M1^(-1) * A2 * M1
# P - матриця в нормальній формі Фробеніуса
P = np.linalg.inv(M1) @ A2 @ M1

# Знаходимо власні значення як корені характеристичного рівняння
# Характеристичний поліном: λ^4 + P[0,0]*λ^3 + P[0,1]*λ^2 + P[0,2]*λ + P[0,3] = 0
V = np.array([-P[0,3], -P[0,2], -P[0,1], -P[0,0], 1])
lambda_values = np.roots(V[::-1])

print("Власні значення:")
for i, l in enumerate(lambda_values, 1):
    print(f"λ_{i} = {l:.5f}")

# Знаходимо власні вектори матриці P
# Для матриці в нормальній формі Фробеніуса власні вектори мають вигляд:
# y = [λ^3, λ^2, λ, 1], де λ - власне значення
Y = np.array([
    [l**3, l**2, l, 1] for l in lambda_values
])

# Перетворюємо власні вектори P на власні вектори A
# S - загальна матриця перетворення
S = M3 @ M2 @ M1
eigenvectors = S @ Y.T

print("\nВласні вектори:")
for i, v in enumerate(eigenvectors.T, 1):
    print(f"v_{i} = {v}")

# Перевірка точності
# Для кожного власного значення λ і відповідного власного вектора v
# перевіряємо рівняння: A * v = λ * v
print("\nПеревірка точності:")
for i, (lambda_i, v) in enumerate(zip(lambda_values, eigenvectors.T), 1):
    error = np.linalg.norm(A @ v - lambda_i * v)
    print(f"Помилка для λ_{i}: {error:.2e}")

# Порівняння з вбудованою функцією
print("\nВласні значення за допомогою numpy:")
np_eigenvalues, np_eigenvectors = np.linalg.eig(A)
for i, ev in enumerate(np_eigenvalues, 1):
    print(f"λ_{i} = {ev:.5f}")
```


## Важливе визначення

Матриця називається невиродженою (або оборотною), якщо її визначник не дорівнює нулю.
