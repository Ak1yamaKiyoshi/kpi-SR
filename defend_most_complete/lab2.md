


Задача лабораторної роботи полягає у тому, щоб розв'язати систему рівнянь. За моїм варіантом матриця симетрична, а отже було використано метод квадратних коренів.


Основна ідея методу полягає у факторизації початкової матриці системи. Ми розкладаємо її на добуток двох трикутних матриць - верхньої трикутної та її транспонованої (нижньої трикутної).


```python
def square_root_method(A, b, precision=6):
    n = len(A)
    T = np.zeros((n, n))
    
    print("Початкова матриця A:")
    print(np.round(A, precision))
    print("\nПочатковий вектор b:")
    print(np.round(b, precision))
    
    # Крок 1: Факторизація A = T'T
    for i in range(n):
        for j in range(i, n):
            if i == j:
                sum_k = sum(T[k, i]**2 for k in range(i))
                T[i, i] = np.sqrt(A[i, i] - sum_k)
```

У цій частині ми починаємо процес факторизації матриці A. Ми обчислюємо діагональні елементи матриці T. Ідея полягає в тому, що кожен діагональний елемент T[i,i] є квадратним коренем з відповідного елемента матриці A[i,i], від якого ми віднімаємо суму квадратів попередніх елементів того ж стовпця матриці T. Це забезпечує, що діагональні елементи T завжди будуть додатними, що важливо для стабільності методу.

```python
            else:
                sum_k = sum(T[k, i] * T[k, j] for k in range(i))
                T[i, j] = (A[i, j] - sum_k) / T[i, i]
            
            T[i, j] = round(T[i, j], precision)
```

Тут ми обчислюємо недіагональні елементи матриці T. Кожен такий елемент T[i,j] обчислюється шляхом віднімання від відповідного елемента A[i,j] суми добутків попередніх елементів відповідних рядка і стовпця матриці T, а потім ділення результату на діагональний елемент T[i,i]. Це забезпечує, що при множенні T на її транспоновану матрицю T' ми отримаємо початкову матрицю A.

```python
    # Крок 2: Розв'язання T'y = b
    y = np.zeros(n)
    for i in range(n):
        sum_k = sum(T[k, i] * y[k] for k in range(i))
        y[i] = (b[i] - sum_k) / T[i, i]
        y[i] = round(y[i], precision)
```

На цьому кроці ми розв'язуємо систему рівнянь T'y = b, де T' - транспонована матриця T. Ця система має нижню трикутну форму, що дозволяє нам обчислювати елементи y послідовно, починаючи з першого. Для кожного елемента y[i] ми віднімаємо від відповідного елемента b[i] суму добутків вже обчислених елементів y на відповідні елементи матриці T, а потім ділимо на діагональний елемент T[i,i].

```python
    # Крок 3: Розв'язання Tx = y
    x = np.zeros(n)
    for i in range(n-1, -1, -1):  # Зворотній хід
        sum_k = sum(T[i, k] * x[k] for k in range(i+1, n))
        x[i] = (y[i] - sum_k) / T[i, i]
        x[i] = round(x[i], precision)
    
    return x
```

На останньому кроці ми розв'язуємо систему Tx = y, де T - верхня трикутна матриця. Ми обчислюємо елементи x у зворотному порядку, починаючи з останнього. Для кожного елемента x[i] ми віднімаємо від відповідного елемента y[i] суму добутків вже обчислених елементів x на відповідні елементи матриці T, а потім ділимо на діагональний елемент T[i,i].

Кожен крок супроводжується округленням до заданої точності, що допомагає контролювати накопичення похибок у процесі обчислень. Виведення проміжних результатів дозволяє нам перевіряти правильність роботи алгоритму на кожному етапі.

Загальна ідея методу полягає в тому, щоб розбити складну задачу розв'язання системи Ax = b на послідовність простіших задач з трикутними матрицями, які можна ефективно розв'язати.

> КОли ми не можемо застосовувати метод холецького?
Метод Холецького не можна застосовувати в наступних випадках:
1. Коли матриця не є симетричною. Метод Холецького розроблений спеціально для симетричних матриць і не працює з несиметричними.
2. Якщо матриця не є додатно визначеною. Додатна визначеність є критичною умовою для застосування методу Холецького, оскільки він базується на розкладі матриці на добуток нижньої трикутної матриці та її транспонованої.
3. При наявності нульових елементів на головній діагоналі матриці. Такі елементи призводять до ділення на нуль у процесі розкладу.
4. Коли матриця є виродженою або близькою до виродженої. У таких випадках метод Холецького може бути чисельно нестабільним.
5. Для матриць з комплексними елементами, якщо не використовується спеціально адаптована версія методу.
У цих ситуаціях слід розглянути альтернативні методи, такі як LU-розклад або інші, більш стійкі чисельні методи.



> Головний елемент у чисельних методах, зокрема в методі Гауса з вибором головного елемента, це елемент матриці, який вибирається як опорний для виконання подальших обчислень. Зазвичай це найбільший за абсолютною величиною елемент у певному стовпці або підматриці. Вибір головного елемента здійснюється для мінімізації накопичення похибок округлення та підвищення стійкості обчислювального процесу. У методі Гауса головний елемент використовується як дільник для обнулення елементів у відповідному стовпці під ним. Вибір найбільшого елемента зменшує вплив похибок округлення, які могли б бути значними при діленні на малі числа.