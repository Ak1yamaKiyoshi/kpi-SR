Ідея метода гюа полягає в тому, щоб квадрат кожного з сусідніх 
коофіцієнтів був більшим за добуток його сусідніх коофіцієнтів. 
У випадку, якщо ця умова порушується , рівняння має принаймні одну пару комплексних коренів 

У той час як у методі штурма, кожна зміна знаку значить
проходження через корінь 
Тобто кожен наступний многочлен є залишком від ділення двох попередніх 
взятим з протилежним знаком 



- - - 


Ми шукаємо корінь рівнняння.


def method_bisection(kof, a, b):
    # Задання точності
    e = 0.000001
    x = 0
    n = 0
    
    # Шукаємо 
    while abs(b - a) > e:
        n += 1
        # Обчислення середньої точки, тобто половину інтервалу
        x = (a + b) / 2 # у межах заданого інтервалу 
        
        # Перевірка знаку функції на кінцях відрізка
        # Перевіряємо, чи міняє функція свій знак в інтервалі a x 
        # ТОбто рахуємо початок інтервалу та середину інтервалу.
        # Якщо їх добуток від'ємний, значить якесь із значень 0
        # тобто значення змінилось 
        if result_function(a, kof) * result_function(x, kof) < 0:
            # І якщо значення змінюється, значить корінь лежить у лівій половині
            b = x
        else:
            # Інакше Корінь знаходиться в правій половині
            a = x
    
    print("Number of iteration:", n)
    return x


def method_chord(kof, a, b):
    e = 0.000001
    
    # Обчислюємо першу та другу похідні.
    # Це потрібно для вибору початкової точки та оцінки збіжності.
    fkof = derivative(kof)
    skof = derivative(fkof)
    
    # Вибір початкової точки базується на теоремі про збіжність методу хорд.
    # Ми вибираємо точку, де функція та її друга похідна мають однаковий знак.
    if result_function((a + b) / 2, fkof) * result_function((a + b) / 2, skof) > 0:
        x0 = b
        x1 = a
    else:
        x0 = a
        x1 = b
    
    current_x = 0
    prev_x = x1
    n = 0
    
    while True:
        n += 1
        # Формула методу хорд. Геометрично, це знаходження точки перетину
        # хорди, що з'єднує точки (x0, f(x0)) та (prev_x, f(prev_x)), з віссю x.
        current_x = prev_x - result_function(prev_x, kof) / (result_function(prev_x, kof) - result_function(x0, kof)) * (prev_x - x0)
        
        # Перевіряємо, чи досягнуто заданої точності.
        # Це оцінка того, наскільки близько ми до справжнього кореня.
        if abs(current_x - prev_x) < e:
            break
        
        prev_x = current_x
    
    print("Number of iteration:", n)
    return current_x

    
def method_newton(kof, a, b):
    e = 0.000001
    
    # Обчислюємо першу та другу похідні.
    # Перша похідна використовується у формулі Ньютона,
    # друга - для вибору початкової точки.
    fkof = derivative(kof)
    skof = derivative(fkof)
    
    # Вибір початкової точки базується на теоремі про збіжність методу Ньютона.
    # Ми вибираємо точку, де функція та її друга похідна мають однаковий знак.
    if result_function((a + b) / 2, fkof) * result_function((a + b) / 2, skof) > 0:
        prev_x = b
    else:
        prev_x = a
    
    current_x = 0
    n = 0
    
    while True:
        n += 1
        # Формула методу Ньютона. Геометрично, це знаходження точки перетину
        # дотичної до графіка функції в точці prev_x з віссю x.
        current_x = prev_x - result_function(prev_x, kof) / result_function(prev_x, fkof)

        # Перевіряємо, чи досягнуто заданої точності.
        if abs(current_x - prev_x) < e:
            break
        
        prev_x = current_x
    
    print("Number of iteration:", n)
    return current_x