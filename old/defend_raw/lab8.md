
Метод рунге-кутта рахує зважене середнє
значення наближень похідної нахилів у інтервалі x+h для обрахунку наступного значення y.
k1 - це нахил на початку інтервалу.
k2 - це нахил у середині інтервалу, використовуючи k1 для оцінки y.
k3 - це також нахил у середині інтервалу, але використовуючи k2.
k4 - це нахил у кінці інтервалу, використовуючи k3.


Метод адамса рахує дивиться на попередні значення у щоб спрогнозувати наступне значення, та уточнити його значеннями минулих похідних.

Метод Адамса дивиться на попередні значення y та їх похідні, щоб спрогнозувати наступне значення (предиктор), а потім уточнює його, використовуючи це прогнозоване значення разом з минулими значеннями та їх похідними (коректор). Цей двоетапний процес дозволяє методу адаптуватися до змін у поведінці функції, забезпечуючи більшу точність, ніж простіші методи.




import numpy as np

def runge_kutta_4(f: callable, x0: float, y0: np.ndarray, xf: float, n: int) -> tuple[np.ndarray, np.ndarray]:
    """
    Метод Рунге-Кутта 4-го порядку для розв'язання систем ЗДР.
    
    Параметри:
    f -- функція, що визначає систему ЗДР dy/dx = f(x, y)
    x0 -- початкове значення x
    y0 -- початковий вектор y
    xf -- кінцеве значення x
    n -- кількість кроків інтегрування
    
    Повертає:
    x -- масив значень x
    y -- масив значень y
    """
    h = (xf - x0) / n  # крок інтегрування
    x = np.linspace(x0, xf, n + 1)  # масив значень x
    y = np.zeros((n + 1, len(y0)))  # масив для зберігання значень y
    y[0] = y0  # початкове значення y

    for i in range(n):
        k1 = h * f(x[i], y[i])
        k2 = h * f(x[i] + h/2, y[i] + k1/2)
        k3 = h * f(x[i] + h/2, y[i] + k2/2)
        k4 = h * f(x[i] + h, y[i] + k3)

        y[i+1] = y[i] + (k1 + 2*k2 + 2*k3 + k4) / 6

        # Обчислення контрольного параметра tau
        """
            k1-k2 нормалізують значення похибки k2-k3 (похибка між двома послідовними наближеннями)
        """
        tau = np.max(np.abs((k2 - k3) / (k1 - k2 + 1e-15)))  # додаємо малу величину для уникнення ділення на нуль
        if tau > 0.1: # Метод рунге кутта не передбачає адаптивної зміни кроку. 
            print(f"Увага: tau = {float(tau):.4f} > 0.1 при x = {float(x[i+1]):.4f}")
    return x, y

def runge_rule(runge_kutta_4, f, x0, y0, xf, n, m):
    """
    Реалізація правила Рунге для оцінки похибки.
    
    Параметри:
    runge_kutta_4 -- функція методу Рунге-Кутта 4-го порядку
    f -- функція, що визначає ЗДР dy/dx = f(x, y)
    x0, y0 -- початкові умови
    xf -- кінцеве значення x
    n -- кількість кроків інтегрування
    m -- порядок похибки методу
    
    Повертає:
    epsilon -- оцінка похибки
    """
    _, y_n = runge_kutta_4(f, x0, y0, xf, n)
    _, y_2n = runge_kutta_4(f, x0, y0, xf, 2*n)
    epsilon = np.max(np.abs(y_n[-1] - y_2n[-1])) / (2**m - 1)
    return epsilon




def adams_method(f, x0, y0, xf, n):
    """
    Метод Адамса для розв'язання звичайних диференціальних рівнянь.

    Параметри:
    f -- функція правої частини ДР: dy/dx = f(x, y)
    x0 -- початкове значення x
    y0 -- початкове значення y
    xf -- кінцеве значення x
    n -- кількість кроків

    Повертає:
    x -- масив значень x
    y -- масив значень y
    """
    h = (xf - x0) / n  # крок
    x = np.linspace(x0, xf, n + 1)
    y = np.zeros(n + 1)
    y[0] = y0

    # Використовуємо метод Рунге-Кутта 4-го порядку для перших 4 точок
    for i in range(3):
        k1 = h * f(x[i], y[i])
        k2 = h * f(x[i] + h/2, y[i] + k1/2)
        k3 = h * f(x[i] + h/2, y[i] + k2/2)
        k4 = h * f(x[i] + h, y[i] + k3)
        y[i+1] = y[i] + (k1 + 2*k2 + 2*k3 + k4) / 6

    # Метод Адамса
    for i in range(3, n):
        # Екстраполяційна формула (предиктор)
        y_pred = y[i] + h/24 * (55*f(x[i], y[i]) - 59*f(x[i-1], y[i-1]) + 
                                37*f(x[i-2], y[i-2]) - 9*f(x[i-3], y[i-3]))
        
        # Інтерполяційна формула (коректор)
        y[i+1] = y[i] + h/24 * (9*f(x[i+1], y_pred) + 19*f(x[i], y[i]) - 
                                5*f(x[i-1], y[i-1]) + f(x[i-2], y[i-2]))

    return x, y





Фазовий портрет у задачі Коші - це графічне представлення розв'язків системи диференціальних рівнянь, яке дозволяє нам візуально осягнути поведінку системи за різних початкових умов. Уявіть собі двовимірний графік, де кожна точка відповідає можливому стану системи, а криві на цьому графіку показують, як система еволюціонує з часом. Ці криві називаються фазовими траєкторіями, і кожна з них відповідає певним початковим умовам - саме тому цей метод такий цінний для задачі Коші.

На фазовому портреті ми можемо побачити ключові елементи поведінки системи. Точки, де система не змінюється з часом, називаються точками рівноваги - це місця, де всі похідні дорівнюють нулю. Напрямок руху вздовж траєкторій зазвичай позначається стрілками, що допомагає зрозуміти, як система розвивається. Особливо важливими є сепаратриси - траєкторії, які розділяють різні типи поведінки системи.

Цей метод дозволяє нам аналізувати стійкість системи, визначати наявність періодичних розв'язків або хаотичної поведінки, і все це без необхідності знаходити точні аналітичні розв'язки. Це особливо цінно для нелінійних систем, де аналітичні методи часто непрактичні або навіть неможливі.

Фазовий портрет також дає нам можливість побачити, як змінюється поведінка системи при зміні параметрів - це називається біфуркаційним аналізом. Ми можемо спостерігати, як малі зміни в параметрах можуть призводити до радикальних змін у поведінці системи.

У контексті задачі Коші фазовий портрет дозволяє нам візуально оцінити вплив різних початкових умов на довгострокову поведінку системи. Ми можемо побачити, чи прямує система до стабільного стану, чи входить у цикл, чи демонструє хаотичну поведінку, і все це на одному графіку.

Таким чином, фазовий портрет є потужним інструментом для якісного аналізу динамічних систем, який дозволяє нам глибоко зрозуміти поведінку системи без необхідності вирішувати складні рівняння аналітично. Це робить його неоціненним у багатьох галузях науки та інженерії, де ми стикаємося з складними динамічними системами.